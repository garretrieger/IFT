<pre class='metadata'>
Title: Incremental Font Transfer
Shortname: IFT
Status: WD
Prepare for TR: yes
Date: 2024-01-16
Group: webfontswg
Level: none
Markup Shorthands: css no
TR: https://www.w3.org/TR/IFT/
ED: https://w3c.github.io/IFT/Overview.html
Editor: Chris Lilley, W3C, https://svgees.us/, w3cid 1438
Editor: Garret Rieger, Google Inc., grieger@google.com, w3cid 73905
Editor: Skef Iterum, Adobe Inc., siterum@adobe.com, w3cid 137857
Abstract: This specification defines a method to incrementally transfer fonts from server to client.
          Incremental transfer allows clients to load only the portions of the font they actually need
          which speeds up font loads and reduces data transfer needed to load the fonts. A font can
          be loaded over multiple requests where each request incrementally adds additional data.
</pre>

<!--
    for things that are not in specref
    https://www.specref.org/
-->

<pre class=link-defaults>
spec:fetch; type:dfn; for:/; text:status
spec:fetch; type:dfn; for:/; text:response
</pre>

<pre class=biblio>
{
  "PFE-report": {
    "href": "https://www.w3.org/TR/PFE-evaluation/",
    "authors": ["Chris Lilley"],
    "status": "Note",
    "publisher": "W3C",
    "title": "Progressive Font Enrichment: Evaluation Report",
    "date": "15 October 2020"
  },

  "Shared-Brotli": {
    "href": "https://datatracker.ietf.org/doc/html/draft-vandevenne-shared-brotli-format-09",
    "authors": [
      "J. Alakuijala",
      "T. Duong",
      "R. Obryk",
      "Z. Szabadka",
      "L. Vandevenne"
    ],
    "status": "Internet Draft",
    "title": "Shared Brotli Compressed Data Format",
    "date": "27 Jul 2021"
  },

  "open-type": {
    "href": "https://docs.microsoft.com/en-us/typography/opentype/spec",
    "authors": [],
    "status": "Note",
    "publisher": "Microsoft",
    "title": "OpenType Specification",
    "date": "December 2021"
  },

  "fetch": {
    "href": "https://fetch.spec.whatwg.org/",
    "authors": [],
    "status": "Living Standard",
    "publisher": "What WG",
    "title": "Fetch Standard",
    "date": "22 May 2023"
  }
}
</pre>

<style>
.conform:hover {background: #31668f; color: white}
.conform:target {padding: 2px; border: 2px solid #AAA; background: #31668f; color: white }

table {
  width: 100%;
}

table, tr {
  border: 1px solid #aaa;
  border-collapse: collapse;
}

th, td {
  padding: 0.5rem;
}
</style>

Introduction {#intro}
=====================

<em>This section is not normative.</em>

Incremental Font Transfer (IFT) is a technology to improve the latency of remote fonts (or "web fonts") on
the web. Without this technology, a browser needs to download every last byte of a font before it can render
any characters using that font. IFT allows the browser to download only some of the bytes in the file, thereby
decreasing the perceived latency between the time when a browser realizes it needs a font and when the
necessary text can be rendered with that font.

The success of WebFonts is unevenly distributed. This specification allows WebFonts to be used where
slow networks, very large fonts, or complex subsetting requirements currently preclude their use. For
example, even using WOFF 2 [[WOFF2]], fonts for CJK languages are too large to be practical.

At a high level IFT works as follows:
* The client downloads an initial font file, which contains some subset of data from the original font.
* Inside the font file there is [[#font-format-extensions|embedded data]] which informs the client about
    a set of [[#font-patch-formats|patches]] which are available and can be used to extend the font.
* The client [[#extending-font-subset|selects, downloads, and applies]] these patches to extend the initial font to
    cover additional characters.

Technical Motivation: Evaluation Report {#evaluation-report}
------------------------------------------------------------

See the Progressive Font Enrichment: Evaluation Report [[PFE-report]] for the investigation which led
to this specification.

Performance Considerations and the use of Incremental Font Transfer {#performance-considerations}
-------------------------------------------------------------------------------------------------

Using incremental transfer may not always be beneficial, depending on the characteristics of the font
and the content being rendered. This section provides non-normative guidance to help decide when
incremental transfer should be utilized.

Incrementally loading a font has a fundamental performance trade off versus loading the whole font.
Simplistically, under incremental transfer less bytes may be transferred at the potential cost of
increasing the total number of network requests being made, and/or increased request processing
latency. In general incremental font transfer will be beneficial where the reduction in latency from
sending less bytes outweighs additional latency introduced by the incremental transfer method.

The first factor to consider is the language of the content being rendered. The evaluation report
contains the results of simulating incremental font transfer across three categories of languages
([[PFE-report#langtype]]). See it's conclusions [[PFE-report#conclusions]] for a discussion of the
anticipated performance of incremental font transfer across the language categories.

Next, how much of the font is expected to be needed? If it's expected that most of the font will be
needed to render the content then incremental font transfer is unlikely to be beneficial. In many cases
however only part of a font is expected to be needed. For example:

* If the font contains support for several languages but a user is expected to only render content
    in a subset of those languages.
       
* If the content being rendered uses a small subset of the total characters in a font. This is
    often the case for Chinese, Japanese, Korean, Emoji, and Icon fonts.

* Only a small amount of text is being rendered. For example a font that is only used for a
    headline.

An alternative to incremental transfer is to break a font into distinct subsets (typically by script)
and use the unicode range feature of @font-face to load only the subsets needed. However, this can
break rendering [[PFE-report#fail-subset]] if there are layout rules between characters in
different subsets. Incremental font transfer does not suffer from this issue as it maintains the
original font and all it's layout rules.

### Reducing the Number of Network Requests ### {#reduce-requests}

As discussed in the previous section the most basic implementation of incremental font transfer will
tend to increase the total number of requests made vs traditional font loading. Since each augmentation
will require at least one round trip time, performance can be negatively impacted if too many requests
are made. It's possible for a client to preemptively request patches for codepoints that are not
currently needed, but expected to be needed in the future. Intelligent use of this feature by an
implementation can help reduce the total number of requests being made. The evaluation report explored
this by testing the performance of a basic character frequency based [[PFE-report#codepredict|codepoint prediction]]
scheme and found it improved overall performance.


Opt-In Mechanism {#opt-in}
==========================

Web pages can choose to opt-in to incremental transfer for a font via the use of a CSS font tech
keyword ([[css-fonts-4#font-tech-definitions]]) inside the ''@font-face'' block. The keyword
<code>incremental</code> is used to indicate the referenced font contains IFT data and should
only be loaded by a user agent which supports incremental font transfer.

<div class=example>
<pre>
@font-face {
    font-family: "MyCoolWebFont";
    src: url("MyCoolWebFont.otf") tech(incremental);
}
</pre>
</div>

@font-face's that include the <code>incremental</code> tech keyword should also include a
[[css-fonts-4#unicode-range-desc|unicode-range descriptor]]. This informs the client which codepoints
are available in the font prior to making the first request, which can be used to avoid requesting
the font unnecessarily.

Note: Each individual <code>@font-face</code> block may or may not opt-in to IFT. This is due to the
variety of ways fonts are used on web pages. Authors have control over which fonts they want to use
this technology with, and which they do not.

Note: the IFT tech keyword can be used in conjunction with other font tech specifiers to perform
font feature selection. For example a <code>@font-face</code> could include two URLs one with
<code>tech(incremental, color-COLRv1)</code> and the other with
<code>tech(incremental, color-COLRv0)</code>.

Offline Usage {#offline-usage}
------------------------------

Special consideration must be taken when saving a page for offline usage that uses an incrementally
transferred font since the saved page won't be able to increment the font if content changes (eg.
due to JavaScript execution). In these cases the page saving mechanism should produce the full font
by using [[#extending-font-subset]] to apply all available patches listed in the font.

Font Subset {#font-subset-info}
===============================

A <dfn dfn>font subset</dfn> is a modified version of a font file [[!iso14496-22]] that contains only the data
needed to render a subset of:

*  the codepoints,
*  [[open-type/featuretags|layout features]],
*  and [[open-type/otvaroverview#terminology|design-variation space]].

supported by the original font. When a subsetted font is used to render text using any combination of the subset
codepoints, [[open-type/featuretags|layout features]], or [[open-type/otvaroverview#terminology|design-variation space]]
it must render identically to the original font. This includes rendering with the use of any optional typographic
features that a renderer may choose to use from the original font, such as hinting instructions.

A <dfn dfn>font subset definition</dfn> describes the minimum data (codepoints, layout features,
variation axis space) that a [=font subset=] must possess.

Note: For convenience the remainder of this document links to the [[open-type]] specification which is a copy of
[[!iso14496-22]].

Data Types {#data-types}
========================

Encoded data structures in the remainder of this specification are described in terms of the data types defined
in [[open-type/otff#data-types]]. As with OpenType all fields use Big Endian byte ordering.

URL Templates {#url-templates}
------------------------------

<!-- TODO write this -->

Extensions to the Font Format {#font-format-extensions}
=======================================================

Incremental fonts follow the existing [[open-type|OpenType]] format, but include two new [[open-type/otff#table-directory|tables]]:
'IFT ' and 'IFTX'. These new tables are both [[#patch-map|patch maps]], which encode a collection of mappings from
[=font subset definition|font subset definitions=] to URLs which host [[#font-patch-formats|patches]] that extend the incremental font.
The mappings from the two tables is unioned together to produce the final mapping. All incremental fonts must contain at least an
'IFT ' table. The 'IFTX' table is optional.

Note: allowing the mapping to be split between two distinct tables allows an incremental font to more easily make use of multiple
patch types. For example all patches of one type can be specified in the 'IFT ' table, and all patches of a second type in the
'IFTX' table. Then those patches can make updates only to one of the mapping tables and avoid making conflicting updates.


Patch Map Table {#patch-map}
----------------------------

A patch map table encodes a list of entries, where each entry has a key and value. The key is a [=font subset definition=] and
the value is a URL and the [[#font-patch-formats]] used by the data at the URL. A map is encoded in one of two formats:

*  Format 1: a limited, but more compact encoding. Encodes a one-to-one mapping from glyph id to patch URLs. Does not support
    [=font subset definitions=] with design space or entries with overlapping subset definitions.

*  Format 2: can encode arbitrary mappings including ones with design space or overlapping subset definitions. However, typically less
    compact then format 1.

### Patch Map Table: Format 1 ### {#patch-map-format-1}

<!-- TODO: summary of this format -->
<!-- TODO: provide normative validation requirements for each encoding -->

<dfn>Format 1 Patch Map</dfn> encoding:
<table>
  <tr>
    <th>Type</th><th>Name</th><th>Description</th>
  </tr>
  <tr>
    <td>uint8</td>
    <td><dfn for="Format 1 Patch Map">format</dfn></td>
    <td>Set to 1, identifies this as format 1.</td>
  </tr>
  <tr>
    <td>uint32</td>
    <td><dfn for="Format 1 Patch Map">reserved</dfn></td>
    <td>Not used, set to 0.</td>
  </tr>
  <tr>
    <td>uint32</td>
    <td><dfn for="Format 1 Patch Map">id</dfn>[4]</td>
    <td>Unique ID used to identify patches that are compatible with this font.</td>
  </tr>
  <tr>
    <td>uint32</td>
    <td><dfn for="Format 1 Patch Map">entryCount</dfn></td>
    <td>Number of entries encoded in this table.</td>
  </tr>
  <tr>
    <td>uint32</td>
    <td><dfn for="Format 1 Patch Map">glyphCount</dfn></td>
    <td>Number of glyphs that mappings are provided for. Must match the numGlyphs field from [[open-type/maxp|maxp]].</td>
  </tr>
  <tr>
    <td>Offset32</td>
    <td><dfn for="Format 1 Patch Map">glyphMapOffset</dfn></td>
    <!-- TODO link -->
    <td>Offset to a [=Glyph Map=] sub table. Offset is from the start of this table.</td>
  </tr>
  <tr>
    <td>Offset32</td>
    <td><dfn for="Format 1 Patch Map">featureMapOffset</dfn></td>
    <td>Offset to a [=Feature Map=] sub table. Offset is from the start of this table.</td>
  </tr>
  <tr>
    <td>uint8</td>
    <td><dfn for="Format 1 Patch Map">appliedEntriesBitMap</dfn>[(entryCount + 7)/8]</td>
    <td>
      A bit map which tracks which entries have been applied. If bit <code>i</code> is set that indicates the patch for entry
      <code>i</code> has been applied to this font. Bit 0 is the least significant bit of appliedEntriesBitMap[0], while bit 7 is
      the most significant bit. Bit 8 is the least significant bit of appliedEntriesBitMap[1] and so on.
    </td>
  </tr>
  <tr>
    <td>uint16</td>
    <td><dfn for="Format 1 Patch Map">uriTemplateLength</dfn></td>
    <td>
      Length of the uriTemplate string.
    </td>
  </tr>
  <tr>
    <td>uint8</td>
    <td><dfn for="Format 1 Patch Map">uriTemplate</dfn>[uriTemplateLength]</td>
    <td>
      A [[UTF-8]] encoded string. Contains a template (TODO) which is used to produce URLs associated with each entry.
    </td>
  </tr>
  <tr>
    <td>uint8</td>
    <td><dfn for="Format 1 Patch Map">patchEncoding</dfn></td>
    <td>
      Specifies the format of the patches linked to by uriTemplate. Using the ID number from the [[#font-patch-formats-summary]] table.
    </td>
  </tr>
</table>

<dfn>Glyph Map</dfn> encoding:

A glyph map table associates each glyph index in the font with an entry index.

<table>
  <tr>
    <th>Type</th><th>Name</th><th>Description</th>
  </tr>
  <tr>
    <td>uint16</td>
    <td><dfn for="Glyph Map">firstMappedGlyph</dfn></td>
    <td>All glyph indices less than firstMappedGlyph are implicitly mapped to entry index 0.</td>
  </tr>
  <tr>
    <td>uint8/uint16</td>
    <td><dfn for="Glyph Map">entryIndex</dfn>[[=Format 1 Patch Map/glyphCount=] - firstMappedGlyph]</td>
    <td>
      The entry index for glyph <code>i</code> is stored in entryIndex[<code>i</code> - firstMappedGlyph]. Array members
      are uint8 if [=Format 1 Patch Map/entryCount=] is less than 256, otherwise they are uint16.
    </td>
  </tr>
</table>


<dfn>Feature Map</dfn> encoding:

A feature map table associates combinations of [[open-type/featuretags|feature tags]] and glyphs with an entry index.

<table>
  <tr>
    <th>Type</th><th>Name</th><th>Description</th>
  </tr>
  <tr>
    <td>uint16</td>
    <td><dfn for="Feature Map">featureCount</dfn></td>
    <td>Number of featureRecords.</td>
  </tr>
  <tr>
    <td>[=FeatureRecord=]</td>
    <td><dfn for="Feature Map">featureRecords</dfn>[featureCount]</td>
    <td>
      Provides mappings for a specific  [[open-type/featuretags|feature tag]]. Sorted by [=FeatureRecord/featureTag=]
      with any feature tag occurring at most once.
    </td>
  </tr>
  <tr>
    <td>[=EntryMapRecord=]</td>
    <td><dfn for="Feature Map">entryMapRecords</dfn>[variable]</td>
    <td>
      Provides the key (entry index) for each feature mapping. The entryMapRecords array contains as many entries as the sum of
      the [=FeatureRecord/entryMapCount=] fields in the [=Feature Map/featureRecords=] array, with entryMapRecords[0] corresponding
      to the first entry of featureRecords[0], entryMapRecords[featureRecord[0].entryMapCount] corresponding to the first entry of
      featureRecords[1], entryMapRecords[featureRecords[0].entryMapCount + featureRecord[1].entryMapCount]] corresponding to the
      first entry of featureRecords[2], and so on.
    </td>
  </tr>
</table>

<dfn>FeatureRecord</dfn> encoding:

<table>
  <tr>
    <th>Type</th><th>Name</th><th>Description</th>
  </tr>
  <tr>
    <td>Tag</td>
    <td><dfn for="FeatureRecord">featureTag</dfn></td>
    <td>The [[open-type/featuretags|feature tag]] this mapping is for.</td>
  </tr>
  <tr>
    <td>uint8/uint16</td>
    <td><dfn for="FeatureRecord">firstEntryIndex</dfn></td>
    <td>
      uint8 if [=Format 1 Patch Map/entryCount=] is less than 256, otherwise uint16.
      The first entry index this record maps too.
    </td>
  </tr>
  <tr>
    <td>uint8/uint16</td>
    <td><dfn for="FeatureRecord">entryMapCount</dfn></td>
    <td>
      uint8 if [=Format 1 Patch Map/entryCount=] is less than 256, otherwise uint16.
      The number of [=EntryMapRecord=]s associated with this feature.
    </td>
  </tr>
</table>

<dfn>EntryMapRecord</dfn> encoding:

<table>
  <tr>
    <th>Type</th><th>Name</th><th>Description</th>
  </tr>
  <tr>
    <td>uint8/uint16</td>
    <td><dfn for="EntryMapRecord">firstEntryIndex</dfn></td>
    <td>
      uint8 if [=Format 1 Patch Map/entryCount=] is less than 256, otherwise uint16.
    </td>
  </tr>
    <tr>
    <td>uint8/uint16</td>
    <td><dfn for="EntryMapRecord">lastEntryIndex</dfn></td>
    <td>
      uint8 if [=Format 1 Patch Map/entryCount=] is less than 256, otherwise uint16.
      Must be greater than or equal to firstEntryIndex.
    </td>
  </tr>
</table>

An entry map record matches any entry indices that are greater than or equal to firstEntryIndex and less than or equal to  lastEntryIndex.

### Patch Map Table: Format 2 ### {#patch-map-format-2}


<!-- TODO add algorithm explaining how to union the two tables -->



<!-- 
TODO:
- how does this interact with woff2
-->

Font Patch Formats {#font-patch-formats}
========================================

In incremental font transfer [=font subset|font subsets=] are extended by loading and applying patches. Due to the different
capabilities required in different situations this specification defines three different patch formats that can be used.

Definitions {#font-patch-definitions}
-------------------------------------

A <dfn dfn>font patch</dfn> is a file which encodes changes to be made to an existing font file. Patches are used to extend
an existing [=font subset=] and provide expanded coverage.

A <dfn dfn>patch format</dfn> is a specified encoding used to encode changes to be applied to a [=font subset=] into a
[=font patch=]. Every [=patch format=] has an associated  <dfn dfn>patch application algorithm</dfn> which takes a
[=font subset=] and a [=font patch=] encoded in the [=patch format=] as input and outputs a new extended
[=font subset=]. Each [=patch application algorithm=] can be categorized as either independent or dependent. Given a set of
[=font patch|font patches=], <code>P</code>, that are all valid to be applied to a specific [=font subset=], <code>F</code>:

<!-- TODO this dependent definition is too strict, dependent patches can in some cases be applied to font subset even if it
     has been modified by independent patches (specifically the per table patch type) -->
* <dfn dfn>dependent</dfn> patches are only valid to be applied to [=font subset=] <code>F</code>. Applying any patches from
    <code>P</code> to [=font subset=] <code>F</code> will change the subset and thus invalidate any remaining dependent patches
    in <code>P</code>.

* <dfn dfn>independent</dfn> patches are only valid to be applied to [=font subset=] <code>F</code> and any [=font subset=] derived
    from F by the application of one or more independent patches from <code>P</code>.

Formats Summary {#font-patch-formats-summary}
---------------------------------------------

The following patch formats are defined by this specification:

<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>ID</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>[[#shared-brotli]]</td>
    <td>[=dependent=]</td>
    <td>1</td>
    <td>A shared brotli encoded binary diff that uses the entire [=font subset=] as a base.</td>
  </tr>
  <tr>
    <td>[[#per-table-shared-brotli]]</td>
    <td>[=dependent=]</td>
    <td>2</td>
    <td>A collection of shared brotli encoded binary diffs that use tables from the [=font subset=] as bases.</td>
  </tr>
  <tr>
    <td>Glyph Keyed</td>
    <td>[=independent=]</td>
    <td>3</td>
    <td>Contains a collection of opaque binary blobs, each associated with a glyph id and table.</td>
  </tr>
</table>

More detailed descriptions of each algorithm can be found in the proceeding sections.

Shared Brotli Patch {#shared-brotli}
------------------------------------

In a shared brotli patch the target file is encoded with [[!RFC7932|brotli compression]] using the
source file as a [[Shared-Brotli#section-3.2|shared LZ77 dictionary]]. A shared brotli encoded patch consists
of a short header followed by brotli encoded data.

<dfn>Shared brotli patch</dfn> encoding:
<table>
  <tr>
    <th>Type</th><th>Name</th><th>Description</th>
  </tr>
  <!-- TODO: include a reserved field for future expansions? -->
  <!-- TODO: include a version field? -->
  <!-- TODO: field for the uncompressed length of brotliStream? -->
  <tr>
    <td>Tag</td>
    <td><dfn for="Shared brotli patch">format</dfn></td>
    <td>Identifies the encoding as shared brotli, set to 'ifbr'</td>
  </tr>
  <tr>
    <!-- TODO link to the IFT table section on ID once added. -->
    <td>uint32</td>
    <td><dfn for="Shared brotli patch">id</dfn>[4]</td>
    <td>The id of the [=font subset=] which this patch can be applied too.</td>
  </tr>
  <tr>
    <td>uint8</td>
    <td><dfn for="Shared brotli patch">brotliStream</dfn>[variable]</td>
    <td>Brotli encoded byte stream.</td>
  </tr>
</table>

<h4 algorithm id="apply-shared-brotli">Applying Shared Brotli Patches</h4>

This algorithm is used to apply a shared brotli patch to extend a [=font subset=] to cover additional codepoints,
features, and/or design-variation space.

<dfn abstract-op>Apply shared brotli patch</dfn>

The inputs to this algorithm are:

* <var>base font subset</var>: a [=font subset=] which is to be extended.

* <var>patch</var>: a [=shared brotli patch=] to be applied to <var>base font subset</var>.

The algorithm outputs:

* <var>extended font subset</var>: a [=font subset=] that has been extended by the <var>patch</var>.

The algorithm:

1. Check that the [=Shared brotli patch/format=] field in <var>patch</var> is equal to 'ifbr', if it is
    not equal then <var>patch</var> is not correctly formatted. Patch application has failed, return
    an error.

<!-- TODO: link to IFT/IFTX section once it's written for the id field. -->
2. Check that the [=Shared brotli patch/id=] field in <var>patch</var> is equal to the at least one of the ids
    found in the 'IFT ' or 'IFTX' table of <var>base font subset</var>. If there is no match, or
    <var>base font subset</var> does not have either an 'IFT ' or 'IFTX' table then patch application has failed,
    return an error.

3. Decode the brotli encoded data in [=Shared brotli patch/brotliStream=] following [[RFC7932#section-10]] and
    using the <var>base font subset</var> as a [[Shared-Brotli#section-3.2|shared LZ77 dictionary]]. Return the decoded
    result as the <var>extended font subset</var>

Per Table Shared Brotli {#per-table-shared-brotli}
--------------------------------------------------

A per table shared brotli patch contains a collection of patches which are applied to the individual
[[open-type/otff#table-directory|font tables]] in the input font file. Each table patch is encoded with
[[!RFC7932|brotli compression]] using the corresponding table from the input font file as a
[[Shared-Brotli#section-3.2|shared LZ77 dictionary]]. A per table shared brotli encoded patch consists of a short header followed
by one or more brotli encoded patches. In addition to patching tables, patches may also replace (existing table data is not used)
or remove tables in a [=font subset=].

<dfn>Per table shared brotli patch</dfn> encoding:
<table>
  <!-- TODO: reserved flags and/or version field? -->
  <tr>
    <th>Type</th><th>Name</th><th>Description</th>
  </tr>
  <tr>
    <td>Tag</td>
    <td><dfn for="Per table shared brotli patch">format</dfn></td>
    <td>Identifies the encoding as shared brotli, set to 'ifbt'</td>
  </tr>
  <tr>
    <!-- TODO link to the IFT table section on ID once added. -->
    <td>uint32</td>
    <td><dfn for="Per table shared brotli patch">id</dfn>[4]</td>
    <td>The id of the [=font subset=] which this patch can be applied too.</td>
  </tr>
  <tr>
    <td>uint16</td>
    <td><dfn for="Per table shared brotli patch">patchesCount</dfn></td>
    <td>The number of entries in the patches array.</td>
  </tr>
  <tr>
    <td>Offset32</td>
    <td><dfn for="Per table shared brotli patch">patches</dfn>[patchesCount+1]</td>
    <td>Each entry is an offset from the start of this table to a [=TablePatch=]. Offsets are sorted in ascending order.</td>
  </tr>
</table>

The difference between two consecutive offsets in the [=Per table shared brotli patch/patches=] array gives the size
of that [=TablePatch=].

<dfn>TablePatch</dfn> encoding:
<table>
  <!-- TODO: field for the uncompressed length of brotliStream? -->
  <tr>
    <th>Type</th><th>Name</th><th>Description</th>
  </tr>
  <tr>
    <td>Tag</td>
    <td><dfn for="TablePatch">tag</dfn></td>
    <td>The tag that identifies the [[open-type/otff#table-directory|font table]] this patch applies too.</td>
  </tr>
  <tr>
    <td>uint8</td>
    <td><dfn for="TablePatch">flags</dfn></td>
    <td>Bit-field. If bit 0 (least significant bit) is set this patch replaces the existing table. If bit 1 is set this table is removed.</td>
  </tr>
  <tr>
    <td>uint8</td>
    <td><dfn for="TablePatch">brotliStream</dfn>[variable]</td>
    <td>Brotli encoded byte stream.</td>
  </tr>
</table>


<h4 algorithm id="apply-per-table-shared-brotli">Applying Per Table Shared Brotli Patches</h4>

This algorithm is used to apply a per table shared brotli patch to extend a [=font subset=] to cover additional codepoints,
features, and/or design-variation space.

<dfn abstract-op>Apply per table shared brotli patch</dfn>

The inputs to this algorithm are:

* <var>base font subset</var>: a [=font subset=] which is to be extended.

* <var>patch</var>: a [=per table shared brotli patch=] to be applied to <var>base font subset</var>.

The algorithm outputs:

* <var>extended font subset</var>: a [=font subset=] that has been extended by the <var>patch</var>.

The algorithm:

1. Check that the [=Per table shared brotli patch/format=] field in <var>patch</var> is equal to 'ifbt', if it is
    not equal then <var>patch</var> is not correctly formatted. Patch application has failed, return
    an error.

<!-- TODO: link to IFT/IFTX section once it's written for the id field. -->
2. Check that the [=Per table shared brotli patch/id=] field in <var>patch</var> is equal to the at least one of the ids
    found in the 'IFT ' or 'IFTX' table of <var>base font subset</var>. If there is no match, or
    <var>base font subset</var> does not have either an 'IFT ' or 'IFTX' table then patch application has failed,
    return an error.

3. For each entry in [=Per table shared brotli patch/patches=], with index <var>i</var>:

    *  Find the [=TablePatch=] associated with index <var>i</var>. The object starts at the offset
        [=Per table shared brotli patch/patches|patches[i]=] and ends at the offset [=Per table shared brotli patch/patches|patches[i+1]=].
        Both offsets are relative to the start of the <var>patch</var>.

    *  If an entry in [=Per table shared brotli patch/patches=] was previously applied that has the same [=TablePatch/tag=] as
        this entry, then ignore this entry and continue the iteration to the next one. Entries are processed in same order as they
        are listed in the [=Per table shared brotli patch/patches=] array.


    *  If bit 0 (least significant bit) of [=TablePatch/flags=] is set then, decode [=TablePatch/brotliStream=] following
        [[RFC7932#section-10]]. No shared dictionary is used. Add a [[open-type/otff#table-directory|table]] to
        <var>extended font subset</var> identified by [=TablePatch/tag=] with it's contents set to the decoded [=TablePatch/brotliStream=].

    *  If bit 1 of [=TablePatch/flags=] is set then, do not copy or add a [[open-type/otff#table-directory|table]] to
        <var>extended font subset</var> identified by [=TablePatch/tag=].

    *  Otherwise, decode [=TablePatch/brotliStream=] following [[RFC7932#section-10]] and using the
        [[open-type/otff#table-directory|table]] identified by [=TablePatch/tag=] in <var>base font subset</var>
        as a [[Shared-Brotli#section-3.2|shared LZ77 dictionary]]. Add a [[open-type/otff#table-directory|table]] to
        <var>extended font subset</var> identified by [=TablePatch/tag=] with it's contents set to the decoded [=TablePatch/brotliStream=].

4. For each [[open-type/otff#table-directory|table]] in <var>base font subset</var> which has a tag that was not found in any of
    the entries processed in step 3, add a copy of that table to <var>extended font subset</var>.

Glyph Keyed {#glyph-keyed}
--------------------------

A glyph keyed patch contains a collection of data chunks that are each associated with a glyph index and a
[[open-type/otff#table-directory|font table]]. The encoded data replaces any existing data for that glyph index in the referenced
[[open-type/otff#table-directory|table]]. Glyph keyed patches can encode data for [[open-type/glyf|glyf]]/[[open-type/loca|loca]],
[[open-type/gvar|gvar]], [[open-type/cff|CFF]], and [[open-type/cff2|CFF2]] tables.

<dfn>Glyph keyed patch</dfn> encoding:
<table>
  <tr>
    <th>Type</th><th>Name</th><th>Description</th>
  </tr>
  <tr>
    <td>Tag</td>
    <td><dfn for="Glyph keyed patch">format</dfn></td>
    <td>Identifies the encoding as glyph keyed, set to 'ifgk'</td>
  </tr>
  <tr>
    <td>uint32</td>
    <td>reserved</td>
    <td>Reserved for future use, set to 0.</td>
  </tr>
  <tr>
    <td>uint32</td>
    <td><dfn for="Glyph keyed patch">id</dfn>[4]</td>
    <td>The id of the [=font subset=] which this patch can be applied too.</td>
  </tr>
  <!-- TODO: we probably need patch id to allow for removal in step 6. -->
  <tr>
    <td>uint32</td>
    <td><dfn for="Glyph keyed patch">length</dfn></td>
    <td>The uncompressed length of [=Glyph keyed patch/brotliStream=].</td>
  </tr>
  <tr>
    <td>uint8</td>
    <td><dfn for="Glyph keyed patch">brotliStream</dfn>[variable]</td>
    <td>Brotli encoded [=GlyphPatches=] table.</td>
  </tr>
</table>

<dfn>GlyphPatches</dfn> encoding:
<table>
  <tr>
    <th>Type</th><th>Name</th><th>Description</th>
  </tr>
  <tr>
    <td>uint32</td>
    <td><dfn for="GlyphPatches">glyphCount</dfn></td>
    <td>The number of glyphs encoded in the patch.</td>
  </tr>
  <tr>
    <td>uint8</td>
    <td><dfn for="GlyphPatches">tableCount</dfn></td>
    <td>The number of [[open-type/otff#table-directory|tables]] the patch has data for.</td>
  </tr>
  <tr>
    <!-- TODO: support larger than 16 bit glyphs. -->
    <td>uint16</td>
    <td><dfn for="GlyphPatches">glyphIds</dfn>[glyphCount]</td>
    <td>An array of glyph indices included in the patch.</td>
  </tr>
  <tr>
    <td>Tag</td>
    <td><dfn for="GlyphPatches">tables</dfn>[tableCount]</td>
    <td>An array of [[open-type/otff#table-directory|tables]] (by tag) included in the patch.</td>
  </tr>
  <tr>
    <td>Offset32</td>
    <td><dfn for="GlyphPatches">glyphDataOffsets</dfn>[glyphCount * tableCount + 1]</td>
    <td>
      An array of offsets of to glyph data for each table. The first [=GlyphPatches/glyphCount=] offsets corresponding to
      [=GlyphPatches/tables|tables[0]=], the next [=GlyphPatches/glyphCount=] offsets (if present) corresponding to
      [=GlyphPatches/tables|tables[1]=], and so on. All offsets are from the start of the [=GlyphPatches=] table.
      Offsets are sorted in ascending order.
    </td>
  </tr>
  <tr>
    <td>uint8</td>
    <td><dfn for="GlyphPatches">glyphData</dfn>[variable]</td>
    <td>
      The actual glyph data picked out by the offsets.
    </td>
  </tr>
</table>

The difference between two consecutive offsets in the [=GlyphPatches/glyphDataOffsets=] array gives the size
of that glyph data.

<h4 algorithm id="apply-glyph-keyed">Applying Glyph Keyed Patches</h4>

This algorithm is used to apply a glyph keyed patch to extend a [=font subset=] to cover additional codepoints,
features, and/or design-variation space.

<dfn abstract-op>Apply glyph keyed patch</dfn>

The inputs to this algorithm are:

* <var>base font subset</var>: a [=font subset=] which is to be extended.

* <var>patch</var>: a [=glyph keyed patch=] to be applied to <var>base font subset</var>.

The algorithm outputs:

* <var>extended font subset</var>: a [=font subset=] that has been extended by the <var>patch</var>.

The algorithm:

1. Check that the [=Glyph keyed patch/format=] field in <var>patch</var> is equal to 'ifgk', if it is
    not equal then <var>patch</var> is not correctly formatted. Patch application has failed, return
    an error.

<!-- TODO: link to IFT/IFTX section once it's written for the id field. -->
2. Check that the [=Glyph keyed patch/id=] field in <var>patch</var> is equal to the at least one of the ids
    found in the 'IFT ' or 'IFTX' table of <var>base font subset</var>. If there is no match, or
    <var>base font subset</var> does not have either an 'IFT ' or 'IFTX' table then patch application has failed,
    return an error.

3. Decode the brotli encoded data in [=Glyph keyed patch/brotliStream=] following [[RFC7932#section-10]]. The
    decoded data is a [=GlyphPatches=] table.

4. For each [[open-type/otff#table-directory|font table]] listed in [=GlyphPatches/tables=], with index <code>i</code>:

    *  Using the corresponding table in <var>base font subset</var>, synthesize
        a new table where the data for each glyph is replaced with the data corresponding to that glyph index
        from [=GlyphPatches/glyphData=] if present, otherwise copied from the corresponding table in <var>base font subset</var> for
        that glyph index.

    *  The patch glyph data for a glyph index is located by finding  [=GlyphPatches/glyphIds|glyphIds[j]=] equal to the glyph index. The
        offset to the associated glyph data is [=GlyphPatches/glyphDataOffsets|glyphDataOffsets[i * glyphCount + j]=]. The length
        of the associated glyph data is [=GlyphPatches/glyphDataOffsets|glyphDataOffsets[i * glyphCount + j + 1]=] minus
        [=GlyphPatches/glyphDataOffsets|glyphDataOffsets[i * glyphCount + j]=].

    *  The specific process for synthesizing the new table, depends on the specified format of the
        [[open-type/otff#table-directory|table]]. Any non-glyph associated data should be copied from the table in
        <var>base font subset</var>. Tables of the type [[open-type/glyf|glyf]]/[[open-type/loca|loca]],
        [[open-type/gvar|gvar]], [[open-type/cff|CFF]], or [[open-type/cff2|CFF2]] are supported. Entries for tables
        of any other types must be ignored.

    *  If <var>base font subset</var> does not have a matching table, return an error.

    *  Insert the synthesized table into <var>extended font subset</var>.

5. For each [[open-type/otff#table-directory|table]] in <var>base font subset</var> which has a tag that was not found in any of
    the entries processed in step 4, add a copy of that table to <var>extended font subset</var>.

6. Modify the mappings in the IFT and IFTX table(s) in <var>extended font subset</var> if present to remove any mapping entries
    that map to this patch. <!-- TODO: this needs to be made more detailed once we have the mapping format sections -->

Extending a Font Subset {#extending-font-subset}
================================================

<!-- TODO -->

<h2 class=no-num id=priv>Privacy Considerations</h2>

<!-- TODO -->

<h2 class=no-num id=sec>Security Considerations</h2>

<!-- TODO -->

<h2 class=no-num id=changes>Changes</h2>

Since the <a href="https://www.w3.org/TR/2022/WD-IFT-20220628/">Working 
  Draft of 28 June 2022</a> (see 
  <a href="https://github.com/w3c/IFT/commits/main/Overview.bs">commit history</a>):

<ul>
  <li>Complete rewrite of the specification. Separate 'Patch Subset' and 'Range Request' methods have been removed in favour
      of a single unified approach.</li>
  <li>Updated citations of rfc9110 and rfc9111 to use new references</li>
  <li>Update privacy section to clarify purpose of checksums</li>
  <li>Split off the range request section back into a separate document</li>
  <li>Removed PatchResponse from the specification</li>
  <li>Removed remaining reference to the old client state</li>
  <li>Consistently used term 'font collection'</li>
  <li>Made IFTP table references consistent</li>
  <li>Added an id for offline usage header</li>
  <li>Updated the responding to patch request section for client state changes</li>
  <li>Updated loading with a cache section for client state changes</li>
  <li>Added client side handling of new unrecognized_ordering field</li>
  <li>Updated handling failed font load section for client state</li>
  <li>Updated the 'Extending font subset' section for client state changes</li>
  <li>Added ClientState object schema</li>
  <li>Added a small section about handling saving a page for offline usage</li>
  <li>Expanded section on reducing the number of network requests</li>
  <li>Clarified how brotli patches are made</li>
  <li>Removed ordering and patched checksum from server response</li>
  <li>Improved markup of algorithms</li>
  <li>Bumped shared brotli spec version to the most recent</li>
  <li>Added a 'should' requirement to have client support both methods</li>
  <li>Added a note about how feature selection interacts with IFT method selection</li>
  <li>Removed mentioned of Transfer-Encoding which isn't support beyond HTTP 1.1</li>
  <li>Added note about what happens when specified method changes to auto</li>
  <li>Reworded IFT Method Selection section to make it more clear</li>
  <li>Added a note about incremental-auto possibly triggering a preflight request</li>
  <li>Dropped use of query parameter with GET</li>
  <li>Updated IFT Method Fallback matrices</li>
  <li>Updated method selection and negotiation sections to support content specified method selection via CSS font tech</li>
  <li>Added "Performance Considerations" section</li>
  <li>Shrank Integer primitive range to match that of an int64_t</li>
  <li>Made HTTP RFC references more specific</li>
</ul>