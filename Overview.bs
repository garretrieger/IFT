<pre class='metadata'>
Title: Incremental Font Transfer
Shortname: IFT
Status: WD
Prepare for TR: yes
Date: 2024-01-16
Group: webfontswg
Level: none
Markup Shorthands: css no
TR: https://www.w3.org/TR/IFT/
ED: https://w3c.github.io/IFT/Overview.html
Editor: Chris Lilley, W3C, https://svgees.us/, w3cid 1438
Editor: Garret Rieger, Google Inc., grieger@google.com, w3cid 73905
Editor: Skef Iterum, Adobe Inc., siterum@adobe.com, w3cid 137857
Abstract: This specification defines a method to incrementally transfer fonts from server to client.
          Incremental transfer allows clients to load only the portions of the font they actually need
          which speeds up font loads and reduces data transfer needed to load the fonts. A font can
          be loaded over multiple requests where each request incrementally adds additional data.
</pre>

<!--
    for things that are not in specref
    https://www.specref.org/
-->

<pre class=link-defaults>
spec:fetch; type:dfn; for:/; text:status
spec:fetch; type:dfn; for:/; text:response
</pre>

<pre class=biblio>
{
  "PFE-report": {
    "href": "https://www.w3.org/TR/PFE-evaluation/",
    "authors": ["Chris Lilley"],
    "status": "Note",
    "publisher": "W3C",
    "title": "Progressive Font Enrichment: Evaluation Report",
    "date": "15 October 2020"
  },

  "Shared-Brotli": {
    "href": "https://datatracker.ietf.org/doc/html/draft-vandevenne-shared-brotli-format-09#section-3.2",
    "authors": [
      "J. Alakuijala",
      "T. Duong",
      "R. Obryk",
      "Z. Szabadka",
      "L. Vandevenne"
    ],
    "status": "Internet Draft",
    "title": "Shared Brotli Compressed Data Format",
    "date": "27 Jul 2021"
  },

  "open-type": {
    "href": "https://docs.microsoft.com/en-us/typography/opentype/spec",
    "authors": [],
    "status": "Note",
    "publisher": "Microsoft",
    "title": "OpenType Specification",
    "date": "December 2021"
  },

  "fetch": {
    "href": "https://fetch.spec.whatwg.org/",
    "authors": [],
    "status": "Living Standard",
    "publisher": "What WG",
    "title": "Fetch Standard",
    "date": "22 May 2023"
  }
}
</pre>

<style>
.conform:hover {background: #31668f; color: white}
.conform:target {padding: 2px; border: 2px solid #AAA; background: #31668f; color: white }
</style>

Introduction {#intro}
=====================

<em>This section is not normative.</em>

Incremental Font Transfer (IFT) is a technology to improve the latency of remote fonts (or "web fonts") on
the web. Without this technology, a browser needs to download every last byte of a font before it can render
any characters using that font. IFT allows the browser to download only some of the bytes in the file, thereby
decreasing the perceived latency between the time when a browser realizes it needs a font and when the
necessary text can be rendered with that font.

The success of WebFonts is unevenly distributed. This specification allows WebFonts to be used where
slow networks, very large fonts, or complex subsetting requirements currently preclude their use. For
example, even using WOFF 2 [[WOFF2]], fonts for CJK languages are too large to be practical.

At a high level IFT works as follows:
* The client downloads an initial font file, which contains some subset of data from the original font.
* Inside the font file there is [[#font-format-extensions|embedded data]] which informs the client about
    a set of [[#font-patch-formats|patches]] which are available and can be used to extend the font.
* The client [[#extending-font-subset|selects, downloads, and applies]] these patches to extend the initial font to
    cover additional characters.

Technical Motivation: Evaluation Report {#evaluation-report}
------------------------------------------------------------

See the Progressive Font Enrichment: Evaluation Report [[PFE-report]] for the investigation which led
to this specification.

Performance Considerations and the use of Incremental Font Transfer {#performance-considerations}
-------------------------------------------------------------------------------------------------

Using incremental transfer may not always be beneficial, depending on the characteristics of the font
and the content being rendered. This section provides non-normative guidance to help decide when
incremental transfer should be utilized.

Incrementally loading a font has a fundamental performance trade off versus loading the whole font.
Simplistically, under incremental transfer less bytes may be transferred at the potential cost of
increasing the total number of network requests being made, and/or increased request processing
latency. In general incremental font transfer will be beneficial where the reduction in latency from
sending less bytes outweighs additional latency introduced by the incremental transfer method.

The first factor to consider is the language of the content being rendered. The evaluation report
contains the results of simulating incremental font transfer across three categories of languages
([[PFE-report#langtype]]). See it's conclusions [[PFE-report#conclusions]] for a discussion of the
anticipated performance of incremental font transfer across the language categories.

Next, how much of the font is expected to be needed? If it's expected that most of the font will be
needed to render the content then incremental font transfer is unlikely to be beneficial. In many cases
however only part of a font is expected to be needed. For example:

* If the font contains support for several languages but a user is expected to only render content
    in a subset of those languages.
       
* If the content being rendered uses a small subset of the total characters in a font. This is
    often the case for Chinese, Japanese, Korean, Emoji, and Icon fonts.

* Only a small amount of text is being rendered. For example a font that is only used for a
    headline.

An alternative to incremental transfer is to break a font into distinct subsets (typically by script)
and use the unicode range feature of @font-face to load only the subsets needed. However, this can
break rendering [[PFE-report#fail-subset]] if there are layout rules between characters in
different subsets. Incremental font transfer does not suffer from this issue as it maintains the
original font and all it's layout rules.

### Reducing the Number of Network Requests ### {#reduce-requests}

As discussed in the previous section the most basic implementation of incremental font transfer will
tend to increase the total number of requests made vs traditional font loading. Since each augmentation
will require at least one round trip time, performance can be negatively impacted if too many requests
are made. It's possible for a client to preemptively request patches for codepoints that are not
currently needed, but expected to be needed in the future. Intelligent use of this feature by an
implementation can help reduce the total number of requests being made. The evaluation report explored
this by testing the performance of a basic character frequency based [[PFE-report#codepredict|codepoint prediction]]
scheme and found it improved overall performance.


Opt-In Mechanism {#opt-in}
==========================

TODO

Font Subset {#font-subset-info}
===============================

A <dfn dfn>font subset</dfn> is a modified version of a font file [[!iso14496-22]] that contains only the data
needed to render a subset of:

*  the codepoints,
*  [[open-type/featuretags|layout features]],
*  and [[open-type/otvaroverview#terminology|design-variation space]].

supported by the original font. When a subsetted font is used to render text using any combination of the subset
codepoints, [[open-type/featuretags|layout features]], or [[open-type/otvaroverview#terminology|design-variation space]]
it must render identically to the original font. This includes rendering with the use of any optional typographic
features that a renderer may choose to use from the original font, such as hinting instructions.

A <dfn dfn>font subset definition</dfn> describes the minimum data (codepoints, layout features,
variation axis space) that a [=font subset=] must possess.

Note: For convenience the remainder of this document links to the [[open-type]] specification which is a copy of
[[!iso14496-22]].

Extensions to the Font Format {#font-format-extensions}
=======================================================

TODO
TODO: how does this interact with woff2

Font Patch Formats {#font-patch-formats}
========================================

TODO

Extending a Font Subset {#extending-font-subset}
================================================

TODO

<h2 class=no-num id=priv>Privacy Considerations</h2>

TODO

<h2 class=no-num id=sec>Security Considerations</h2>

TODO

<h2 class=no-num id=changes>Changes</h2>

Since the <a href="https://www.w3.org/TR/2022/WD-IFT-20220628/">Working 
  Draft of 28 June 2022</a> (see 
  <a href="https://github.com/w3c/IFT/commits/main/Overview.bs">commit history</a>):

<ul>
  <li>Complete rewrite of the specification. Separate 'Patch Subset' and 'Range Request' methods have been removed in favour
      of a single unified approach.</li>
  <li>Updated citations of rfc9110 and rfc9111 to use new references</li>
  <li>Update privacy section to clarify purpose of checksums</li>
  <li>Split off the range request section back into a separate document</li>
  <li>Removed PatchResponse from the specification</li>
  <li>Removed remaining reference to the old client state</li>
  <li>Consistently used term 'font collection'</li>
  <li>Made IFTP table references consistent</li>
  <li>Added an id for offline usage header</li>
  <li>Updated the responding to patch request section for client state changes</li>
  <li>Updated loading with a cache section for client state changes</li>
  <li>Added client side handling of new unrecognized_ordering field</li>
  <li>Updated handling failed font load section for client state</li>
  <li>Updated the 'Extending font subset' section for client state changes</li>
  <li>Added ClientState object schema</li>
  <li>Added a small section about handling saving a page for offline usage</li>
  <li>Expanded section on reducing the number of network requests</li>
  <li>Clarified how brotli patches are made</li>
  <li>Removed ordering and patched checksum from server response</li>
  <li>Improved markup of algorithms</li>
  <li>Bumped shared brotli spec version to the most recent</li>
  <li>Added a 'should' requirement to have client support both methods</li>
  <li>Added a note about how feature selection interacts with IFT method selection</li>
  <li>Removed mentioned of Transfer-Encoding which isn't support beyond HTTP 1.1</li>
  <li>Added note about what happens when specified method changes to auto</li>
  <li>Reworded IFT Method Selection section to make it more clear</li>
  <li>Added a note about incremental-auto possibly triggering a preflight request</li>
  <li>Dropped use of query parameter with GET</li>
  <li>Updated IFT Method Fallback matrices</li>
  <li>Updated method selection and negotiation sections to support content specified method selection via CSS font tech</li>
  <li>Added "Performance Considerations" section</li>
  <li>Shrank Integer primitive range to match that of an int64_t</li>
  <li>Made HTTP RFC references more specific</li>
</ul>